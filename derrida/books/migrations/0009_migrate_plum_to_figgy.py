# -*- coding: utf-8 -*-
# Generated by Django 1.11.5 on 2018-03-19 20:01
from __future__ import unicode_literals

from django.db import migrations
from djiffy.models import IIIFPresentation
from piffle import iiif
import requests


from derrida.books.management.commands.import_digitaleds import DerridaManifestImporter


def migrate_plum_to_figgy(apps, schema_editor):
    '''migrate old Plum Manifest and Canvas URIs to new Figgy equivalents'''

    Manifest = apps.get_model('djiffy', 'Manifest')
    Canvas = apps.get_model('djiffy', 'Canvas')
    Intervention = apps.get_model('interventions', 'Intervention')

    # use existing import/update logic to update manifest & canvas data
    # after URLs have been migrated
    mnf_importer = DerridaManifestImporter(update=True)

    # only manifests with plum.princeton urls need migration
    for dbmanif in Manifest.objects.filter(uri__contains='plum.princeton'):
        # equivalent figgy uri will redirect to new canonical uuid uri
        plum_uri = dbmanif.uri
        figgy_uri = plum_uri.replace('https://plum.princeton', 'https://figgy.princeton')
        print(plum_uri)
        response = requests.head(figgy_uri)
        # expecting a 302 found; ignore if we got something else
        if not response.status_code == requests.codes.found:
            # error/warn?
            next

        # update database manifest with new url
        dbmanif.uri = response.headers['location']
        print(dbmanif.uri)

        # retrieve the figgy manifest at the new url
        newmanif = IIIFPresentation.from_url(response.headers['location'])

        # loop through canvases in the manifest to make a lookup
        # based on short id
        canvas_by_id = {}
        for canvas in newmanif.sequences[0].canvases:
            canvas_by_id[canvas.local_identifier] = canvas

        # loop through canvases stored in the database for this manifest
        # and update them
        for dbcanvas in dbmanif.canvases.all():
            # update canvas uri and save in the database
            dbcanvas.uri = canvas_by_id[dbcanvas.short_id].id
            dbcanvas.save()

            # NOTE: not updating other canvas metadata, because
            # the existing import/update script should handle that
            # once the urls have been migrated

        # save the manifest with the new figgy url
        dbmanif.save()

        # update manifest & canvas labels, image urls, and other metadata
        # FIXME: temporarily disable; getting a 406 response
        # mnf_importer.import_manifest(newmanif, newmanif.id)

        # find and update all interventions associated with canvases for the
        # current digital edition
        for intvtn in Intervention.objects.filter(uri__contains=plum_uri):
            # interventions have a db-association with canvas objects,
            # but also reference canvas URI as annotation target and
            # and IIIF image url in image selection
            old_canvas_id = intvtn.uri.rsplit('/')[-1]

            # update annotated canvas uri
            new_canvas = canvas_by_id[old_canvas_id]
            intvtn.uri = new_canvas.id

            # use piffle iiif image handling to update iiif server and
            # image id without modifying other image parameters
            # - parse image selection uri as iiif image
            img = iiif.IIIFImageClient.init_from_url(intvtn.extra_data['image_selection']['uri'])
            # - load iiif image service as iiifimage
            figgy_img = iiif.IIIFImageClient(*new_canvas.images[0].resource.service.id.rsplit('/', 1))
            # update existing iiif image url with new server & image id
            img.api_endpoint = figgy_img.api_endpoint
            img.image_id = figgy_img.image_id
            # image uri is stored in two places, so update both
            intvtn.extra_data['image_selection']['uri'] = str(img)
            intvtn.extra_data['image_selection']['src'] = str(img)
            intvtn.save()


class Migration(migrations.Migration):

    dependencies = [
        ('books', '0008_instance_work_year_copy_unique_together'),
    ]

    operations = [
        migrations.RunPython(
            code=migrate_plum_to_figgy,
            reverse_code=migrations.RunPython.noop,
        ),
    ]
